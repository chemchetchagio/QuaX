import 'dart:convert';
import 'dart:ui';

import 'package:flutter_cache/flutter_cache.dart' as cache;
import 'package:quax/client/headers.dart';
import 'package:quax/utils/misc.dart';
import 'package:http/http.dart' as http;
import 'package:logging/logging.dart';

Future<bool> isLanguageSupportedForTranslation(String lang) async {
  // TODO: Cache this response, per host, for x amount of time
  var res = await TranslationAPI.getSupportedLanguages();
  if (res.success) {
    return findInJSONArray(res.body, 'code', getShortSystemLocale());
  }

  throw res;
}

class TranslationAPIResult {
  final bool success;
  final dynamic body;
  final String? errorMessage;

  TranslationAPIResult({required this.success, required this.body, this.errorMessage});
}

// TODO
class TranslationAPI {
  static final log = Logger('TranslationAPI');

  static Future<TranslationAPIResult> getSupportedLanguages() async {
    var key = 'translation.supported_languages';

    return cacheRequest(key, () async {
      var response = await http.get(Uri.https('libretranslate.com', '/languages'));
      return await parseResponse(response, 'Unable to get supported languages');
    });
  }

  static Future<TranslationAPIResult> translate(
      Locale locale, String id, List<String> text, String sourceLanguage) async {
    var formData = {'id': id, 'dst_lang': locale.toLanguageTag(), 'content_type': 'POST'};

    var key = 'translation.$sourceLanguage.$id';

    var res = await cacheRequest(key, () async {
      Future<http.Response> getTranslation() async {
        final translationUri = Uri.https('api.x.com', '/2/grok/translation.json');
        return await http.post(translationUri, body: jsonEncode(formData), headers: {
          ...await TwitterHeaders.getHeaders(translationUri),
          'Content-Type': 'text/plain;charset=UTF-8',
          'Accept-Encoding': 'gzip, deflate, br, zstd'
        });
      }

      const int numberOfRetries = 3;

      for (int i = 0; i < numberOfRetries; ++i) {
        try {
          return await parseResponse(await getTranslation(), 'Unable to send translation request');
        } on FormatException {
          // Wait a bit while the translation is fully generated by Grok
          await Future.delayed(Duration(seconds: 1));
        }
      }
      return TranslationAPIResult(success: false, body: {}, errorMessage: "Translation is not ready yet, retry later.");
    });

    return res;
  }

  static Future<TranslationAPIResult> cacheRequest(
      String key, Future<TranslationAPIResult> Function() makeRequest) async {
    var result = await cache.load(key);
    if (result != null && result == true) {
      return TranslationAPIResult(success: true, body: jsonDecode(result));
    }

// Otherwise, make the request
    var response = await makeRequest();
    if (response.success) {
// Cache the response if it's a successful one
      await cache.write(key, jsonEncode(response.body));

      return TranslationAPIResult(success: true, body: response.body);
    }

// Otherwise, we always want to return the error without caching
    return response;
  }

  static Future<TranslationAPIResult> parseResponse(http.Response response, String errorUnableTo) async {
    final utf8Response = utf8.decode(response.bodyBytes);
    final body = jsonDecode(utf8Response);
    log.info("Translation result: $body");
    if (response.statusCode == 200 && body is Map<String, dynamic>) {
      if (body.containsKey("error")){
        var error = body['error'];
        return TranslationAPIResult(success: false, body: body, errorMessage: error['message'] ?? error['code'] ?? '');
      }
      return TranslationAPIResult(success: true, body: body);
    }

    String message = '';

    switch (response.statusCode) {
      case 400:
        RegExp languageNotSupported = RegExp(r"^\w+\ is\ not\ supported$");

        var error = body['error'];
        if (languageNotSupported.hasMatch(error)) {
          message = 'Language $error';
        } else {
          message = error;
        }
        break;
      case 403:
        message = 'Error: Banned from translation API';
        break;
      case 429:
        message = 'Error: Sending too many frequent translation requests';
        break;
      case 500:
        message = 'Error: The translation API failed to translate the tweet';
        break;
    }

    return TranslationAPIResult(success: false, body: body, errorMessage: message);
  }
}
